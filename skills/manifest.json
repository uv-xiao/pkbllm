[
  {
    "canonical_path": "knowledge/ML/18-multimodal/audiocraft",
    "description": "PyTorch library for audio generation including text-to-music (MusicGen) and text-to-sound (AudioGen). Use when you need to generate music from text descriptions, create sound effects, or perform melody-conditioned music generation.",
    "name": "uv-audiocraft-audio-generation",
    "slug": "uv-audiocraft-audio-generation"
  },
  {
    "canonical_path": "knowledge/ML/14-agents/autogpt",
    "description": "Autonomous AI agent platform for building and deploying continuous agents. Use when creating visual workflow agents, deploying persistent autonomous agents, or building complex multi-step AI automation systems.",
    "name": "uv-autogpt-agents",
    "slug": "uv-autogpt-agents"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/awq",
    "description": "Activation-aware weight quantization for 4-bit LLM compression with 3x speedup and minimal accuracy loss. Use when deploying large models (7B-70B) on limited GPU memory, when you need faster inference than GPTQ with better accuracy preservation, or for instruction-tuned and multimodal models. MLSys 2024 Best Paper Award winner.",
    "name": "uv-awq-quantization",
    "slug": "uv-awq-quantization"
  },
  {
    "canonical_path": "knowledge/ML/03-fine-tuning/axolotl",
    "description": "Expert guidance for fine-tuning LLMs with Axolotl - YAML configs, 100+ models, LoRA/QLoRA, DPO/KTO/ORPO/GRPO, multimodal support",
    "name": "uv-axolotl",
    "slug": "uv-axolotl"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/blip-2",
    "description": "Vision-language pre-training framework bridging frozen image encoders and LLMs. Use when you need image captioning, visual question answering, image-text retrieval, or multimodal chat with state-of-the-art zero-shot performance.",
    "name": "uv-blip-2-vision-language",
    "slug": "uv-blip-2-vision-language"
  },
  {
    "canonical_path": "bootstrap/skill-maintenance",
    "description": "Maintain and curate the pkbllm skills repository. Use when adding/importing a new skill, merging skills from external repos, updating or refactoring existing skills, regenerating the generated `skills/` mirror, or ensuring licensing/compliance and naming conventions (all skills must start with `uv-`).",
    "name": "uv-bootstrap-skill-maintenance",
    "slug": "uv-bootstrap-skill-maintenance"
  },
  {
    "canonical_path": "productivity/brainstorming",
    "description": "You MUST use this before any creative work - creating features, building components, adding functionality, or modifying behavior. Explores user intent, requirements and design before implementation.",
    "name": "uv-brainstorming",
    "slug": "uv-brainstorming"
  },
  {
    "canonical_path": "knowledge/ML/15-rag/chroma",
    "description": "Open-source embedding database for AI applications. Store embeddings and metadata, perform vector and full-text search, filter by metadata. Simple 4-function API. Scales from notebooks to production clusters. Use for semantic search, RAG applications, or document retrieval. Best for local development and open-source projects.",
    "name": "uv-chroma",
    "slug": "uv-chroma"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/clip",
    "description": "OpenAI's model connecting vision and language. Enables zero-shot image classification, image-text matching, and cross-modal retrieval. Trained on 400M image-text pairs. Use for image search, content moderation, or vision-language tasks without fine-tuning. Best for general-purpose image understanding.",
    "name": "uv-clip",
    "slug": "uv-clip"
  },
  {
    "canonical_path": "knowledge/ML/07-safety-alignment/constitutional-ai",
    "description": "Anthropic's method for training harmless AI through self-improvement. Two-phase approach - supervised learning with self-critique/revision, then RLAIF (RL from AI Feedback). Use for safety alignment, reducing harmful outputs without human labels. Powers Claude's safety system.",
    "name": "uv-constitutional-ai",
    "slug": "uv-constitutional-ai"
  },
  {
    "canonical_path": "human/slider/content-prompts",
    "description": "Convert raw material into per-page Content PROMPTs by analyzing content density, intent, and slide usage. Outputs $HUMAN_MATERIAL_PATH/slides/<deck>/prompts/content/<deck>.md. Use when the user has notes/materials and wants a well-planned per-page content prompt before styling.",
    "name": "uv-content-prompts",
    "slug": "uv-content-prompts"
  },
  {
    "canonical_path": "knowledge/ML/14-agents/crewai",
    "description": "Multi-agent orchestration framework for autonomous AI collaboration. Use when building teams of specialized agents working together on complex tasks, when you need role-based agent collaboration with memory, or for production workflows requiring sequential/hierarchical execution. Built without LangChain dependencies for lean, fast execution.",
    "name": "uv-crewai-multi-agent",
    "slug": "uv-crewai-multi-agent"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/deepspeed",
    "description": "Expert guidance for distributed training with DeepSpeed - ZeRO optimization stages, pipeline parallelism, FP16/BF16/FP8, 1-bit Adam, sparse attention",
    "name": "uv-deepspeed",
    "slug": "uv-deepspeed"
  },
  {
    "canonical_path": "productivity/dispatching-parallel-agents",
    "description": "Use when facing 2+ independent tasks that can be worked on without shared state or sequential dependencies",
    "name": "uv-dispatching-parallel-agents",
    "slug": "uv-dispatching-parallel-agents"
  },
  {
    "canonical_path": "knowledge/ML/01-model-architecture/torchtitan",
    "description": "Provides PyTorch-native distributed LLM pretraining using torchtitan with 4D parallelism (FSDP2, TP, PP, CP). Use when pretraining Llama 3.1, DeepSeek V3, or custom models at scale from 8 to 512+ GPUs with Float8, torch.compile, and distributed checkpointing.",
    "name": "uv-distributed-llm-pretraining-torchtitan",
    "slug": "uv-distributed-llm-pretraining-torchtitan"
  },
  {
    "canonical_path": "knowledge/ML/16-prompt-engineering/dspy",
    "description": "Build complex AI systems with declarative programming, optimize prompts automatically, create modular RAG systems and agents with DSPy - Stanford NLP's framework for systematic LM programming",
    "name": "uv-dspy",
    "slug": "uv-dspy"
  },
  {
    "canonical_path": "knowledge/ML/11-evaluation/bigcode-evaluation-harness",
    "description": "Evaluates code generation models across HumanEval, MBPP, MultiPL-E, and 15+ benchmarks with pass@k metrics. Use when benchmarking code models, comparing coding abilities, testing multi-language support, or measuring code generation quality. Industry standard from BigCode Project used by HuggingFace leaderboards.",
    "name": "uv-evaluating-code-models",
    "slug": "uv-evaluating-code-models"
  },
  {
    "canonical_path": "knowledge/ML/11-evaluation/lm-evaluation-harness",
    "description": "Evaluates LLMs across 60+ academic benchmarks (MMLU, HumanEval, GSM8K, TruthfulQA, HellaSwag). Use when benchmarking model quality, comparing models, reporting academic results, or tracking training progress. Industry standard used by EleutherAI, HuggingFace, and major labs. Supports HuggingFace, vLLM, APIs.",
    "name": "uv-evaluating-llms-harness",
    "slug": "uv-evaluating-llms-harness"
  },
  {
    "canonical_path": "productivity/executing-plans",
    "description": "Use when you have a written implementation plan to execute in a separate session with review checkpoints",
    "name": "uv-executing-plans",
    "slug": "uv-executing-plans"
  },
  {
    "canonical_path": "knowledge/ML/15-rag/faiss",
    "description": "Facebook's library for efficient similarity search and clustering of dense vectors. Supports billions of vectors, GPU acceleration, and various index types (Flat, IVF, HNSW). Use for fast k-NN search, large-scale vector retrieval, or when you need pure similarity search without metadata. Best for high-performance applications.",
    "name": "uv-faiss",
    "slug": "uv-faiss"
  },
  {
    "canonical_path": "productivity/find-skills",
    "description": "Helps users discover and install agent skills when they ask questions like \"how do I do X\", \"find a skill for X\", \"is there a skill that can...\", or express interest in extending capabilities. This skill should be used when the user is looking for functionality that might exist as an installable skill.",
    "name": "uv-find-skills",
    "slug": "uv-find-skills"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/trl-fine-tuning",
    "description": "Fine-tune LLMs using reinforcement learning with TRL - SFT for instruction tuning, DPO for preference alignment, PPO/GRPO for reward optimization, and reward model training. Use when need RLHF, align model with preferences, or train from human feedback. Works with HuggingFace Transformers.",
    "name": "uv-fine-tuning-with-trl",
    "slug": "uv-fine-tuning-with-trl"
  },
  {
    "canonical_path": "productivity/finishing-a-development-branch",
    "description": "Use when implementation is complete, all tests pass, and you need to decide how to integrate the work - guides completion of development work by presenting structured options for merge, PR, or cleanup",
    "name": "uv-finishing-a-development-branch",
    "slug": "uv-finishing-a-development-branch"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/gguf",
    "description": "GGUF format and llama.cpp quantization for efficient CPU/GPU inference. Use when deploying models on consumer hardware, Apple Silicon, or when needing flexible quantization from 2-8 bit without GPU requirements.",
    "name": "uv-gguf-quantization",
    "slug": "uv-gguf-quantization"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/gptq",
    "description": "Post-training 4-bit quantization for LLMs with minimal accuracy loss. Use for deploying large models (70B, 405B) on consumer GPUs, when you need 4\u00d7 memory reduction with <2% perplexity degradation, or for faster inference (3-4\u00d7 speedup) vs FP16. Integrates with transformers and PEFT for QLoRA fine-tuning.",
    "name": "uv-gptq",
    "slug": "uv-gptq"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/grpo-rl-training",
    "description": "Expert guidance for GRPO/RL fine-tuning with TRL for reasoning and task-specific model training",
    "name": "uv-grpo-rl-training",
    "slug": "uv-grpo-rl-training"
  },
  {
    "canonical_path": "knowledge/ML/16-prompt-engineering/guidance",
    "description": "Control LLM output with regex and grammars, guarantee valid JSON/XML/code generation, enforce structured formats, and build multi-step workflows with Guidance - Microsoft Research's constrained generation framework",
    "name": "uv-guidance",
    "slug": "uv-guidance"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/hqq",
    "description": "Half-Quadratic Quantization for LLMs without calibration data. Use when quantizing models to 4/3/2-bit precision without needing calibration datasets, for fast quantization workflows, or when deploying with vLLM or HuggingFace Transformers.",
    "name": "uv-hqq-quantization",
    "slug": "uv-hqq-quantization"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/accelerate",
    "description": "Simplest distributed training API. 4 lines to add distributed support to any PyTorch script. Unified API for DeepSpeed/FSDP/Megatron/DDP. Automatic device placement, mixed precision (FP16/BF16/FP8). Interactive config, single launch command. HuggingFace ecosystem standard.",
    "name": "uv-huggingface-accelerate",
    "slug": "uv-huggingface-accelerate"
  },
  {
    "canonical_path": "knowledge/ML/02-tokenization/huggingface-tokenizers",
    "description": "Fast tokenizers optimized for research and production. Rust-based implementation tokenizes 1GB in <20 seconds. Supports BPE, WordPiece, and Unigram algorithms. Train custom vocabularies, track alignments, handle padding/truncation. Integrates seamlessly with transformers. Use when you need high-performance tokenization or custom tokenizer training.",
    "name": "uv-huggingface-tokenizers",
    "slug": "uv-huggingface-tokenizers"
  },
  {
    "canonical_path": "knowledge/ML/01-model-architecture/litgpt",
    "description": "Implements and trains LLMs using Lightning AI's LitGPT with 20+ pretrained architectures (Llama, Gemma, Phi, Qwen, Mistral). Use when need clean model implementations, educational understanding of architectures, or production fine-tuning with LoRA/QLoRA. Single-file implementations, no abstraction layers.",
    "name": "uv-implementing-llms-litgpt",
    "slug": "uv-implementing-llms-litgpt"
  },
  {
    "canonical_path": "human/init-human-material-repo",
    "description": "Initialize a dedicated HUMAN_MATERIAL_PATH git repository for generated human-facing materials. Use when a user asks to set up a new materials repo/folder for slides/manuscripts/exercises, create the expected file structure under $HUMAN_MATERIAL_PATH, and create a local-only .OPENROUTER_API_KEY file for slider rendering.",
    "name": "uv-init-human-material-repo",
    "slug": "uv-init-human-material-repo"
  },
  {
    "canonical_path": "knowledge/ML/16-prompt-engineering/instructor",
    "description": "Extract structured data from LLM responses with Pydantic validation, retry failed extractions automatically, parse complex JSON with type safety, and stream partial results with Instructor - battle-tested structured output library",
    "name": "uv-instructor",
    "slug": "uv-instructor"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/knowledge-distillation",
    "description": "Compress large language models using knowledge distillation from teacher to student models. Use when deploying smaller models with retained performance, transferring GPT-4 capabilities to open-source models, or reducing inference costs. Covers temperature scaling, soft targets, reverse KLD, logit distillation, and MiniLLM training strategies.",
    "name": "uv-knowledge-distillation",
    "slug": "uv-knowledge-distillation"
  },
  {
    "canonical_path": "knowledge/ML/09-infrastructure/lambda-labs",
    "description": "Reserved and on-demand GPU cloud instances for ML training and inference. Use when you need dedicated GPU instances with simple SSH access, persistent filesystems, or high-performance multi-node clusters for large-scale training.",
    "name": "uv-lambda-labs-gpu-cloud",
    "slug": "uv-lambda-labs-gpu-cloud"
  },
  {
    "canonical_path": "knowledge/ML/14-agents/langchain",
    "description": "Framework for building LLM-powered applications with agents, chains, and RAG. Supports multiple providers (OpenAI, Anthropic, Google), 500+ integrations, ReAct agents, tool calling, memory management, and vector store retrieval. Use for building chatbots, question-answering systems, autonomous agents, or RAG applications. Best for rapid prototyping and production deployments.",
    "name": "uv-langchain",
    "slug": "uv-langchain"
  },
  {
    "canonical_path": "knowledge/ML/17-observability/langsmith",
    "description": "LLM observability platform for tracing, evaluation, and monitoring. Use when debugging LLM applications, evaluating model outputs against datasets, monitoring production systems, or building systematic testing pipelines for AI applications.",
    "name": "uv-langsmith-observability",
    "slug": "uv-langsmith-observability"
  },
  {
    "canonical_path": "knowledge/ML/12-inference-serving/llama-cpp",
    "description": "Runs LLM inference on CPU, Apple Silicon, and consumer GPUs without NVIDIA hardware. Use for edge deployment, M1/M2/M3 Macs, AMD/Intel GPUs, or when CUDA is unavailable. Supports GGUF quantization (1.5-8 bit) for reduced memory and 4-10\u00d7 speedup vs PyTorch on CPU.",
    "name": "uv-llama-cpp",
    "slug": "uv-llama-cpp"
  },
  {
    "canonical_path": "knowledge/ML/03-fine-tuning/llama-factory",
    "description": "Expert guidance for fine-tuning LLMs with LLaMA-Factory - WebUI no-code, 100+ models, 2/3/4/5/6/8-bit QLoRA, multimodal support",
    "name": "uv-llama-factory",
    "slug": "uv-llama-factory"
  },
  {
    "canonical_path": "knowledge/ML/07-safety-alignment/llamaguard",
    "description": "Meta's 7-8B specialized moderation model for LLM input/output filtering. 6 safety categories - violence/hate, sexual content, weapons, substances, self-harm, criminal planning. 94-95% accuracy. Deploy with vLLM, HuggingFace, Sagemaker. Integrates with NeMo Guardrails.",
    "name": "uv-llamaguard",
    "slug": "uv-llamaguard"
  },
  {
    "canonical_path": "knowledge/ML/14-agents/llamaindex",
    "description": "Data framework for building LLM applications with RAG. Specializes in document ingestion (300+ connectors), indexing, and querying. Features vector indices, query engines, agents, and multi-modal support. Use for document Q&A, chatbots, knowledge retrieval, or building RAG pipelines. Best for data-centric LLM applications.",
    "name": "uv-llamaindex",
    "slug": "uv-llamaindex"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/llava",
    "description": "Large Language and Vision Assistant. Enables visual instruction tuning and image-based conversations. Combines CLIP vision encoder with Vicuna/LLaMA language models. Supports multi-turn image chat, visual question answering, and instruction following. Use for vision-language chatbots or image understanding tasks. Best for conversational image analysis.",
    "name": "uv-llava",
    "slug": "uv-llava"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/long-context",
    "description": "Extend context windows of transformer models using RoPE, YaRN, ALiBi, and position interpolation techniques. Use when processing long documents (32k-128k+ tokens), extending pre-trained models beyond original context limits, or implementing efficient positional encodings. Covers rotary embeddings, attention biases, interpolation methods, and extrapolation strategies for LLMs.",
    "name": "uv-long-context",
    "slug": "uv-long-context"
  },
  {
    "canonical_path": "knowledge/ML/01-model-architecture/mamba",
    "description": "State-space model with O(n) complexity vs Transformers' O(n\u00b2). 5\u00d7 faster inference, million-token sequences, no KV cache. Selective SSM with hardware-aware design. Mamba-1 (d_state=16) and Mamba-2 (d_state=128, multi-head). Models 130M-2.8B on HuggingFace.",
    "name": "uv-mamba-architecture",
    "slug": "uv-mamba-architecture"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/miles",
    "description": "Provides guidance for enterprise-grade RL training using miles, a production-ready fork of slime. Use when training large MoE models with FP8/INT4, needing train-inference alignment, or requiring speculative RL for maximum throughput.",
    "name": "uv-miles-rl-training",
    "slug": "uv-miles-rl-training"
  },
  {
    "canonical_path": "knowledge/ML/20-ml-paper-writing",
    "description": "Write publication-ready ML/AI papers for NeurIPS, ICML, ICLR, ACL, AAAI, COLM. Use when drafting papers from research repos, structuring arguments, verifying citations, or preparing camera-ready submissions. Includes LaTeX templates, reviewer guidelines, and citation verification workflows.",
    "name": "uv-ml-paper-writing",
    "slug": "uv-ml-paper-writing"
  },
  {
    "canonical_path": "knowledge/ML/13-mlops/mlflow",
    "description": "Track ML experiments, manage model registry with versioning, deploy models to production, and reproduce experiments with MLflow - framework-agnostic ML lifecycle platform",
    "name": "uv-mlflow",
    "slug": "uv-mlflow"
  },
  {
    "canonical_path": "knowledge/ML/09-infrastructure/modal",
    "description": "Serverless GPU cloud platform for running ML workloads. Use when you need on-demand GPU access without infrastructure management, deploying ML models as APIs, or running batch jobs with automatic scaling.",
    "name": "uv-modal-serverless-gpu",
    "slug": "uv-modal-serverless-gpu"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/model-merging",
    "description": "Merge multiple fine-tuned models using mergekit to combine capabilities without retraining. Use when creating specialized models by blending domain-specific expertise (math + coding + chat), improving performance beyond single models, or experimenting rapidly with model variants. Covers SLERP, TIES-Merging, DARE, Task Arithmetic, linear merging, and production deployment strategies.",
    "name": "uv-model-merging",
    "slug": "uv-model-merging"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/model-pruning",
    "description": "Reduce LLM size and accelerate inference using pruning techniques like Wanda and SparseGPT. Use when compressing models without retraining, achieving 50% sparsity with minimal accuracy loss, or enabling faster inference on hardware accelerators. Covers unstructured pruning, structured pruning, N:M sparsity, magnitude pruning, and one-shot methods.",
    "name": "uv-model-pruning",
    "slug": "uv-model-pruning"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/moe-training",
    "description": "Train Mixture of Experts (MoE) models using DeepSpeed or HuggingFace. Use when training large-scale models with limited compute (5\u00d7 cost reduction vs dense models), implementing sparse architectures like Mixtral 8x7B or DeepSeek-V3, or scaling model capacity without proportional compute increase. Covers MoE architectures, routing mechanisms, load balancing, expert parallelism, and inference optimization.",
    "name": "uv-moe-training",
    "slug": "uv-moe-training"
  },
  {
    "canonical_path": "knowledge/ML/01-model-architecture/nanogpt",
    "description": "Educational GPT implementation in ~300 lines. Reproduces GPT-2 (124M) on OpenWebText. Clean, hackable code for learning transformers. By Andrej Karpathy. Perfect for understanding GPT architecture from scratch. Train on Shakespeare (CPU) or OpenWebText (multi-GPU).",
    "name": "uv-nanogpt",
    "slug": "uv-nanogpt"
  },
  {
    "canonical_path": "knowledge/ML/05-data-processing/nemo-curator",
    "description": "GPU-accelerated data curation for LLM training. Supports text/image/video/audio. Features fuzzy deduplication (16\u00d7 faster), quality filtering (30+ heuristics), semantic deduplication, PII redaction, NSFW detection. Scales across GPUs with RAPIDS. Use for preparing high-quality training datasets, cleaning web data, or deduplicating large corpora.",
    "name": "uv-nemo-curator",
    "slug": "uv-nemo-curator"
  },
  {
    "canonical_path": "knowledge/ML/11-evaluation/nemo-evaluator",
    "description": "Evaluates LLMs across 100+ benchmarks from 18+ harnesses (MMLU, HumanEval, GSM8K, safety, VLM) with multi-backend execution. Use when needing scalable evaluation on local Docker, Slurm HPC, or cloud platforms. NVIDIA's enterprise-grade platform with container-first architecture for reproducible benchmarking.",
    "name": "uv-nemo-evaluator-sdk",
    "slug": "uv-nemo-evaluator-sdk"
  },
  {
    "canonical_path": "knowledge/ML/07-safety-alignment/nemo-guardrails",
    "description": "NVIDIA's runtime safety framework for LLM applications. Features jailbreak detection, input/output validation, fact-checking, hallucination detection, PII filtering, toxicity detection. Uses Colang 2.0 DSL for programmable rails. Production-ready, runs on T4 GPU.",
    "name": "uv-nemo-guardrails",
    "slug": "uv-nemo-guardrails"
  },
  {
    "canonical_path": "knowledge/ML/04-mechanistic-interpretability/nnsight",
    "description": "Provides guidance for interpreting and manipulating neural network internals using nnsight with optional NDIF remote execution. Use when needing to run interpretability experiments on massive models (70B+) without local GPU resources, or when working with any PyTorch architecture.",
    "name": "uv-nnsight-remote-interpretability",
    "slug": "uv-nnsight-remote-interpretability"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/openrlhf",
    "description": "High-performance RLHF framework with Ray+vLLM acceleration. Use for PPO, GRPO, RLOO, DPO training of large models (7B-70B+). Built on Ray, vLLM, ZeRO-3. 2\u00d7 faster than DeepSpeedChat with distributed architecture and GPU resource sharing.",
    "name": "uv-openrlhf-training",
    "slug": "uv-openrlhf-training"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/flash-attention",
    "description": "Optimizes transformer attention with Flash Attention for 2-4x speedup and 10-20x memory reduction. Use when training/running transformers with long sequences (>512 tokens), encountering GPU memory issues with attention, or need faster inference. Supports PyTorch native SDPA, flash-attn library, H100 FP8, and sliding window attention.",
    "name": "uv-optimizing-attention-flash",
    "slug": "uv-optimizing-attention-flash"
  },
  {
    "canonical_path": "knowledge/ML/16-prompt-engineering/outlines",
    "description": "Guarantee valid JSON/XML/code structure during generation, use Pydantic models for type-safe outputs, support local models (Transformers, vLLM), and maximize inference speed with Outlines - dottxt.ai's structured generation library",
    "name": "uv-outlines",
    "slug": "uv-outlines"
  },
  {
    "canonical_path": "knowledge/ML/03-fine-tuning/peft",
    "description": "Parameter-efficient fine-tuning for LLMs using LoRA, QLoRA, and 25+ methods. Use when fine-tuning large models (7B-70B) with limited GPU memory, when you need to train <1% of parameters with minimal accuracy loss, or for multi-adapter serving. HuggingFace's official library integrated with transformers ecosystem.",
    "name": "uv-peft-fine-tuning",
    "slug": "uv-peft-fine-tuning"
  },
  {
    "canonical_path": "knowledge/ML/17-observability/phoenix",
    "description": "Open-source AI observability platform for LLM tracing, evaluation, and monitoring. Use when debugging LLM applications with detailed traces, running evaluations on datasets, or monitoring production AI systems with real-time insights.",
    "name": "uv-phoenix-observability",
    "slug": "uv-phoenix-observability"
  },
  {
    "canonical_path": "knowledge/ML/15-rag/pinecone",
    "description": "Managed vector database for production AI applications. Fully managed, auto-scaling, with hybrid search (dense + sparse), metadata filtering, and namespaces. Low latency (<100ms p95). Use for production RAG, recommendation systems, or semantic search at scale. Best for serverless, managed infrastructure.",
    "name": "uv-pinecone",
    "slug": "uv-pinecone"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/pytorch-fsdp2",
    "description": "Adds PyTorch FSDP2 (fully_shard) to training scripts with correct init, sharding, mixed precision/offload config, and distributed checkpointing. Use when models exceed single-GPU memory or when you need DTensor-based sharding with DeviceMesh.",
    "name": "uv-pytorch-fsdp2",
    "slug": "uv-pytorch-fsdp2"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/pytorch-lightning",
    "description": "High-level PyTorch framework with Trainer class, automatic distributed training (DDP/FSDP/DeepSpeed), callbacks system, and minimal boilerplate. Scales from laptop to supercomputer with same code. Use when you want clean training loops with built-in best practices.",
    "name": "uv-pytorch-lightning",
    "slug": "uv-pytorch-lightning"
  },
  {
    "canonical_path": "knowledge/ML/04-mechanistic-interpretability/pyvene",
    "description": "Provides guidance for performing causal interventions on PyTorch models using pyvene's declarative intervention framework. Use when conducting causal tracing, activation patching, interchange intervention training, or testing causal hypotheses about model behavior.",
    "name": "uv-pyvene-interventions",
    "slug": "uv-pyvene-interventions"
  },
  {
    "canonical_path": "knowledge/ML/15-rag/qdrant",
    "description": "High-performance vector similarity search engine for RAG and semantic search. Use when building production RAG systems requiring fast nearest neighbor search, hybrid search with filtering, or scalable vector storage with Rust-powered performance.",
    "name": "uv-qdrant-vector-search",
    "slug": "uv-qdrant-vector-search"
  },
  {
    "canonical_path": "knowledge/ML/10-optimization/bitsandbytes",
    "description": "Quantizes LLMs to 8-bit or 4-bit for 50-75% memory reduction with minimal accuracy loss. Use when GPU memory is limited, need to fit larger models, or want faster inference. Supports INT8, NF4, FP4 formats, QLoRA training, and 8-bit optimizers. Works with HuggingFace Transformers.",
    "name": "uv-quantizing-models-bitsandbytes",
    "slug": "uv-quantizing-models-bitsandbytes"
  },
  {
    "canonical_path": "knowledge/ML/05-data-processing/ray-data",
    "description": "Scalable data processing for ML workloads. Streaming execution across CPU/GPU, supports Parquet/CSV/JSON/images. Integrates with Ray Train, PyTorch, TensorFlow. Scales from single machine to 100s of nodes. Use for batch inference, data preprocessing, multi-modal data loading, or distributed ETL pipelines.",
    "name": "uv-ray-data",
    "slug": "uv-ray-data"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/ray-train",
    "description": "Distributed training orchestration across clusters. Scales PyTorch/TensorFlow/HuggingFace from laptop to 1000s of nodes. Built-in hyperparameter tuning with Ray Tune, fault tolerance, elastic scaling. Use when training massive models across multiple machines or running distributed hyperparameter sweeps.",
    "name": "uv-ray-train",
    "slug": "uv-ray-train"
  },
  {
    "canonical_path": "productivity/receiving-code-review",
    "description": "Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation",
    "name": "uv-receiving-code-review",
    "slug": "uv-receiving-code-review"
  },
  {
    "canonical_path": "productivity/requesting-code-review",
    "description": "Use when completing tasks, implementing major features, or before merging to verify work meets requirements",
    "name": "uv-requesting-code-review",
    "slug": "uv-requesting-code-review"
  },
  {
    "canonical_path": "knowledge/ML/01-model-architecture/rwkv",
    "description": "RNN+Transformer hybrid with O(n) inference. Linear time, infinite context, no KV cache. Train like GPT (parallel), infer like RNN (sequential). Linux Foundation AI project. Production at Windows, Office, NeMo. RWKV-7 (March 2025). Models up to 14B parameters.",
    "name": "uv-rwkv-architecture",
    "slug": "uv-rwkv-architecture"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/segment-anything",
    "description": "Foundation model for image segmentation with zero-shot transfer. Use when you need to segment any object in images using points, boxes, or masks as prompts, or automatically generate all object masks in an image.",
    "name": "uv-segment-anything-model",
    "slug": "uv-segment-anything-model"
  },
  {
    "canonical_path": "knowledge/ML/15-rag/sentence-transformers",
    "description": "Framework for state-of-the-art sentence, text, and image embeddings. Provides 5000+ pre-trained models for semantic similarity, clustering, and retrieval. Supports multilingual, domain-specific, and multimodal models. Use for generating embeddings for RAG, semantic search, or similarity tasks. Best for production embedding generation.",
    "name": "uv-sentence-transformers",
    "slug": "uv-sentence-transformers"
  },
  {
    "canonical_path": "knowledge/ML/02-tokenization/sentencepiece",
    "description": "Language-independent tokenizer treating text as raw Unicode. Supports BPE and Unigram algorithms. Fast (50k sentences/sec), lightweight (6MB memory), deterministic vocabulary. Used by T5, ALBERT, XLNet, mBART. Train on raw text without pre-tokenization. Use when you need multilingual support, CJK languages, or reproducible tokenization.",
    "name": "uv-sentencepiece",
    "slug": "uv-sentencepiece"
  },
  {
    "canonical_path": "knowledge/ML/12-inference-serving/vllm",
    "description": "Serves LLMs with high throughput using vLLM's PagedAttention and continuous batching. Use when deploying production LLM APIs, optimizing inference latency/throughput, or serving models with limited GPU memory. Supports OpenAI-compatible endpoints, quantization (GPTQ/AWQ/FP8), and tensor parallelism.",
    "name": "uv-serving-llms-vllm",
    "slug": "uv-serving-llms-vllm"
  },
  {
    "canonical_path": "knowledge/ML/12-inference-serving/sglang",
    "description": "Fast structured generation and serving for LLMs with RadixAttention prefix caching. Use for JSON/regex outputs, constrained decoding, agentic workflows with tool calls, or when you need 5\u00d7 faster inference than vLLM with prefix sharing. Powers 300,000+ GPUs at xAI, AMD, NVIDIA, and LinkedIn.",
    "name": "uv-sglang",
    "slug": "uv-sglang"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/simpo",
    "description": "Simple Preference Optimization for LLM alignment. Reference-free alternative to DPO with better performance (+6.4 points on AlpacaEval 2.0). No reference model needed, more efficient than DPO. Use for preference alignment when want simpler, faster training than DPO/PPO.",
    "name": "uv-simpo-training",
    "slug": "uv-simpo-training"
  },
  {
    "canonical_path": "knowledge/ML/09-infrastructure/skypilot",
    "description": "Multi-cloud orchestration for ML workloads with automatic cost optimization. Use when you need to run training or batch jobs across multiple clouds, leverage spot instances with auto-recovery, or optimize GPU costs across providers.",
    "name": "uv-skypilot-multi-cloud-orchestration",
    "slug": "uv-skypilot-multi-cloud-orchestration"
  },
  {
    "canonical_path": "human/slider/slider-plan",
    "description": "Plan the slider workflow end-to-end by selecting which repo skills to run (content-prompts, styled-prompts, styled-artifacts) based on the user\u2019s starting input (materials or existing prompts) and requested output (content prompt, styled prompt, images, PDF, PPTX). Uses $HUMAN_MATERIAL_PATH/slides/<deck>/ as the working root.",
    "name": "uv-slider-plan",
    "slug": "uv-slider-plan"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/slime",
    "description": "Provides guidance for LLM post-training with RL using slime, a Megatron+SGLang framework. Use when training GLM models, implementing custom data generation workflows, or needing tight Megatron-LM integration for RL scaling.",
    "name": "uv-slime-rl-training",
    "slug": "uv-slime-rl-training"
  },
  {
    "canonical_path": "knowledge/ML/04-mechanistic-interpretability/saelens",
    "description": "Provides guidance for training and analyzing Sparse Autoencoders (SAEs) using SAELens to decompose neural network activations into interpretable features. Use when discovering interpretable features, analyzing superposition, or studying monosemantic representations in language models.",
    "name": "uv-sparse-autoencoder-training",
    "slug": "uv-sparse-autoencoder-training"
  },
  {
    "canonical_path": "knowledge/ML/19-emerging-techniques/speculative-decoding",
    "description": "Accelerate LLM inference using speculative decoding, Medusa multiple heads, and lookahead decoding techniques. Use when optimizing inference speed (1.5-3.6\u00d7 speedup), reducing latency for real-time applications, or deploying models with limited compute. Covers draft models, tree-based attention, Jacobi iteration, parallel token generation, and production deployment strategies.",
    "name": "uv-speculative-decoding",
    "slug": "uv-speculative-decoding"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/stable-diffusion",
    "description": "State-of-the-art text-to-image generation with Stable Diffusion models via HuggingFace Diffusers. Use when generating images from text prompts, performing image-to-image translation, inpainting, or building custom diffusion pipelines.",
    "name": "uv-stable-diffusion-image-generation",
    "slug": "uv-stable-diffusion-image-generation"
  },
  {
    "canonical_path": "human/slider/styled-artifacts",
    "description": "Generate slide images and final PDF/PPTX from v2 styled prompts ($HUMAN_MATERIAL_PATH/slides/<deck>/prompts/styled/<deck>.md), storing intermediates in $HUMAN_MATERIAL_PATH/slides/<deck>/artifacts/<deck>/work/. Use when the user asks to render/generate/export slides from a Styled PROMPT into images/PDF/PPTX.",
    "name": "uv-styled-artifacts",
    "slug": "uv-styled-artifacts"
  },
  {
    "canonical_path": "human/slider/styled-prompts",
    "description": "Convert per-page Content PROMPTs into design-complete Styled PROMPTs using a Markdown style brief, inferring the best layout per page during creation. Outputs $HUMAN_MATERIAL_PATH/slides/<deck>/prompts/styled/<deck>.md, ready for image/PDF/PPT generation.",
    "name": "uv-styled-prompts",
    "slug": "uv-styled-prompts"
  },
  {
    "canonical_path": "productivity/subagent-driven-development",
    "description": "Use when executing implementation plans with independent tasks in the current session",
    "name": "uv-subagent-driven-development",
    "slug": "uv-subagent-driven-development"
  },
  {
    "canonical_path": "productivity/systematic-debugging",
    "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "name": "uv-systematic-debugging",
    "slug": "uv-systematic-debugging"
  },
  {
    "canonical_path": "knowledge/ML/13-mlops/tensorboard",
    "description": "Visualize training metrics, debug models with histograms, compare experiments, visualize model graphs, and profile performance with TensorBoard - Google's ML visualization toolkit",
    "name": "uv-tensorboard",
    "slug": "uv-tensorboard"
  },
  {
    "canonical_path": "knowledge/ML/12-inference-serving/tensorrt-llm",
    "description": "Optimizes LLM inference with NVIDIA TensorRT for maximum throughput and lowest latency. Use for production deployment on NVIDIA GPUs (A100/H100), when you need 10-100x faster inference than PyTorch, or for serving models with quantization (FP8/INT4), in-flight batching, and multi-GPU scaling.",
    "name": "uv-tensorrt-llm",
    "slug": "uv-tensorrt-llm"
  },
  {
    "canonical_path": "productivity/test-driven-development",
    "description": "Use when implementing any feature or bugfix, before writing implementation code",
    "name": "uv-test-driven-development",
    "slug": "uv-test-driven-development"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/torchforge",
    "description": "Provides guidance for PyTorch-native agentic RL using torchforge, Meta's library separating infra from algorithms. Use when you want clean RL abstractions, easy algorithm experimentation, or scalable training with Monarch and TorchTitan.",
    "name": "uv-torchforge-rl-training",
    "slug": "uv-torchforge-rl-training"
  },
  {
    "canonical_path": "knowledge/ML/08-distributed-training/megatron-core",
    "description": "Trains large language models (2B-462B parameters) using NVIDIA Megatron-Core with advanced parallelism strategies. Use when training models >1B parameters, need maximum GPU efficiency (47% MFU on H100), or require tensor/pipeline/sequence/context/expert parallelism. Production-ready framework used for Nemotron, LLaMA, DeepSeek.",
    "name": "uv-training-llms-megatron",
    "slug": "uv-training-llms-megatron"
  },
  {
    "canonical_path": "knowledge/ML/04-mechanistic-interpretability/transformer-lens",
    "description": "Provides guidance for mechanistic interpretability research using TransformerLens to inspect and manipulate transformer internals via HookPoints and activation caching. Use when reverse-engineering model algorithms, studying attention patterns, or performing activation patching experiments.",
    "name": "uv-transformer-lens-interpretability",
    "slug": "uv-transformer-lens-interpretability"
  },
  {
    "canonical_path": "knowledge/ML/03-fine-tuning/unsloth",
    "description": "Expert guidance for fast fine-tuning with Unsloth - 2-5x faster training, 50-80% less memory, LoRA/QLoRA optimization",
    "name": "uv-unsloth",
    "slug": "uv-unsloth"
  },
  {
    "canonical_path": "productivity/using-git-worktrees",
    "description": "Use when starting feature work that needs isolation from current workspace or before executing implementation plans - creates isolated git worktrees with smart directory selection and safety verification",
    "name": "uv-using-git-worktrees",
    "slug": "uv-using-git-worktrees"
  },
  {
    "canonical_path": "productivity/using-superpowers",
    "description": "Use when starting any conversation - establishes how to find and use skills, requiring Skill tool invocation before ANY response including clarifying questions",
    "name": "uv-using-superpowers",
    "slug": "uv-using-superpowers"
  },
  {
    "canonical_path": "productivity/verification-before-completion",
    "description": "Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always",
    "name": "uv-verification-before-completion",
    "slug": "uv-verification-before-completion"
  },
  {
    "canonical_path": "knowledge/ML/06-post-training/verl",
    "description": "Provides guidance for training LLMs with reinforcement learning using verl (Volcano Engine RL). Use when implementing RLHF, GRPO, PPO, or other RL algorithms for LLM post-training at scale with flexible infrastructure backends.",
    "name": "uv-verl-rl-training",
    "slug": "uv-verl-rl-training"
  },
  {
    "canonical_path": "knowledge/ML/13-mlops/weights-and-biases",
    "description": "Track ML experiments with automatic logging, visualize training in real-time, optimize hyperparameters with sweeps, and manage model registry with W&B - collaborative MLOps platform",
    "name": "uv-weights-and-biases",
    "slug": "uv-weights-and-biases"
  },
  {
    "canonical_path": "knowledge/ML/18-multimodal/whisper",
    "description": "OpenAI's general-purpose speech recognition model. Supports 99 languages, transcription, translation to English, and language identification. Six model sizes from tiny (39M params) to large (1550M params). Use for speech-to-text, podcast transcription, or multilingual audio processing. Best for robust, multilingual ASR.",
    "name": "uv-whisper",
    "slug": "uv-whisper"
  },
  {
    "canonical_path": "productivity/writing-plans",
    "description": "Use when you have a spec or requirements for a multi-step task, before touching code",
    "name": "uv-writing-plans",
    "slug": "uv-writing-plans"
  },
  {
    "canonical_path": "productivity/writing-skills",
    "description": "Use when creating new skills, editing existing skills, or verifying skills work before deployment",
    "name": "uv-writing-skills",
    "slug": "uv-writing-skills"
  }
]
